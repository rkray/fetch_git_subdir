#!/usr/bin/ruby
# Author: Ren√© Kray <rene@kray.info>

require 'optparse'
require 'json'
require 'pp'
require 'net/http'
require 'openssl'
require 'base64'
require 'uri'

class FetchGitSubdir
    attr_accessor :version, :verbose, :log, :conf

    def initialize
        @conf={
            :debug          => nil,
            :uri            => nil,
            :passvarname    => "GITPASS",
            :readpass       => nil,
            :verbose        => nil,
            :branch         => "master",
            :path           => nil,
            :topleveldir    => nil
        }
        option_parser
    end

    def run
        #self.send @conf[:mode]
        update_path
        debug "update_private_token"
        update_private_token
        debug "update_project_id"
        update_project_id
        debug @conf

        get_dirtree
    end

    private

    # analyze the option and update the config
    def update_path
        unless @conf[:path].nil?

            # remove leading /
            if @conf[:path][0] == '/'
                @conf[:path]=@conf[:path][1..-1]
            end

            # if there is an trailing / than remove the / and set @conf[:dopleveldir]=tru
            if @conf[:path][-1] == '/'
                @conf[:path]=@conf[:path][0..-2]
                @conf[:topleveldir]=true
            end

            # set @conf[:basedir]
            if @conf[:path].scan('/').length > 0
                @conf[:basedir]=@conf[:path].split('/')[0..-2].join('/')+'/'
            end
        end
    end

    def get_dirtree
        debug "enter get_dirtree"
        
        # TODO
        # add logic to decide here to create a top dir or not

        get_subdir @conf[:path]
    end

    # TODO
    # implement the create option, if create is false, no directory should be 
    def get_subdir(dir=nil,create=true)
        debug "enter get_subdir"

        newdir=nil
        # create subdir
        if((create == true) and (dir != nil))
            newdir=dir.sub(%r(^#{@conf[:basedir]}),"")
            unless(Dir.exists? newdir)
                Dir.mkdir(newdir)
            else
                debug %(directory #{newdir} already exists)
            end        
        end

        # check for options
        args=[]
        args<<%(path=#{dir}) unless dir.nil?
        args<<%(ref_name=#{@conf[:branch]}) unless @conf[:branch].nil?
        
        # define path
        path="/api/v3/projects/#{@conf[:project_id]}/repository/tree"
        
        # add options to path unless args is empty
        path+="?"+args.join("&") unless args.empty?

        # get directory content 
        result=get path
        
        result.each do |entry|
            # print tree unless @conf[:verbose] is nil
            unless @conf[:verbose].nil?
                unless dir.nil?
                    puts %(#{dir}/#{entry['name']} [#{entry['type']}])
                else
                    puts %(#{entry['name']} [#{entry['type']}])
                end
            end
            pp entry

            # TODO
            # check here the path: if it specify a file/blob we could pull the data and
            # print directly to stdout, if the regarding option is set
            #uri = URI('https://gitlab-test/api/v3/projects/2/repository/blobs/master?filepath=lib/library1.lib')
            if entry['type']=='blob'
                # build remote path
                remote_filepath=''
                remote_filepath+=dir+'/' unless dir.nil?
                remote_filepath+=entry['name']
                basepath="/api/v3/projects/#{@conf[:project_id]}/repository/blobs/#{@conf[:branch]}"
                option="filepath=#{remote_filepath}"
                path="#{basepath}?#{option}"

                result=get path
                unless newdir.nil?
                    out_file = File.new(newdir+'/'+entry['name'], "w")
                else
                    out_file = File.new(entry['name'], "w")
                end
                out_file.puts result
                out_file.close
            end

            # call get_subdir for all directories
            if entry['type']=='tree'
                if dir.nil?
                    get_subdir entry['name']
                else
                    get_subdir dir+"/"+entry['name']
                end
            end
        end
    end

    def update_project_id
        path="/api/v3/projects"
        debug "get path"
        r=get path
        debug "collect data"
        r.each{|project|
            if (
                (project['http_url_to_repo'] == @conf[:uri]) or
                (project['web_url'] == @conf[:uri])
            )
                @conf[:project_id]=project['id']
            end
        }
    end

    def update_private_token
        if @conf[:readpass]
            # read pass from stdin
            pass=STDIN.read
            puts "---- PASS -----",pass,'---------------'
        else
            # read pass from environment
            pass=ENV[@conf[:passvarname]]
        end

        path="/api/v3/session"
        #postdata=URI.encode("login=r#{@conf[:username]}&password=#{pass}")
        postdata=URI.encode("login=bla&password=fuu")
        r=post path,postdata
        debug "AUTHRESULT",r
        @conf[:privat_token]=r['private_token']
        debug @conf
    end

    def get(path)
        debug "GET",path
        http=connection
        debug http.inspect
        data=""
        resp = http.get(
            path,
            'PRIVATE-TOKEN' => @conf[:privat_token]
        ){|line|
            data+=line
        }
        if(resp.content_type=="application/json")
            return JSON.parse(data)
        else
            return data
        end
    end

    def post(path,postdata)
        data=''
        pass=ENV[@conf[:passvarname]]
        postdata=URI.encode("login=#{@conf[:username]}&password=#{pass}")
        http=connection
        resp = http.post(path,postdata){|l|data+=l}
        if(resp.content_type=="application/json")
            return JSON.parse(data)
        else
            return data
        end
    end

    # generate a new http/https connection object
    def connection
        debug "create connection",@conf[:uri]
        uri=URI(@conf[:uri])
        debug "Net::HTTP.new", uri.host, uri.port
        http = Net::HTTP.new(uri.host, uri.port)

        # TODO
        # check URI for http/https
        http.use_ssl = true

        # TODO
        # make it configureable over dcommand line flags
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        
        return http
    end

    def examples
        cmd=File.basename $0
        return [
            "",
            "  Examples:",
            "    # read password from environment",
            "    PASS=123 #{cmd} -p PASS -u user -r https://...",
            "",
            "    # read password from stdin",
            "    echo 123 | ssh user@host '#{cmd} -s -u user -r https://...'",
            "",
            "    # example repo url",
            "    #{cmd} -r https://gitlab.mydomain.com/team/testapi.git"
        ].join("\n")
    end

    def option_parser
        option_parser = OptionParser.new do |opts|
            opts.banner = "Usage: #{File.basename $0} [options]"
            opts.on("-h", "--help", "Prints this help") do
                puts opts.help
                puts examples
                exit
            end
            opts.on( "-d", "--debug", "enable debug mode") do
                @conf[:debug] = true
            end
            opts.on( "-v", "--verbose", "enable verbose printing") do
                @conf[:verbose] = true
            end
            # for now disable modes
            # opts.on( "-m", "--mode (gitlab|git)", "set mode, default is 'gitlab'") do |option|
            #     @conf[:mode]=option
            # end
            opts.on( "-u", "--username USERNAME", "set username") do |option|
                @conf[:username]=option
            end
            opts.on( "-s", "--readpass", "try to read the password from stdin") do
                @conf[:readpass]=true
            end
            opts.on( "-p", "--passvarname NAME",
                "the name with the environment variable",
                "default is GITPASS"
            ) do |option|
                @conf[:passvarname]=option
            end
            opts.on( "-r", "--repository URI",
                "HTTP/HTTPS repository URL as shown by gitlab","project page"
            ) do |option|
                @conf[:uri]=option
            end
            opts.on( "-a", "--path PATH", "fetch all files from PATH") do |option|
                @conf[:path]=option
            end
        end
        option_parser.parse!
    end

    def debug *a
        if @conf[:debug]==true
            pp a
        end
    end
    
end

# don't run this part neither load from another script nor irb
if $0 == __FILE__
    @fgs = FetchGitSubdir.new
    
    @fgs.run
end
