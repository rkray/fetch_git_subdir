#!/usr/bin/ruby
# Author: Ren√© Kray <rene@kray.info>

require 'optparse'
require 'json'
require 'pp'
require 'net/http'
require 'openssl'
require 'base64'
require 'uri'

class FetchGitSubdir
    attr_accessor :version, :verbose, :log, :conf

    def initialize
        @conf={
            :debug          => nil,
            :uri            => nil,
            :passvarname    => "GITPASS",
            :verbose        => nil
        }
        option_parser
    end

    def run
        #self.send @conf[:mode]

        debug "update_private_token"
        update_private_token
        debug "update_project_id"
        update_project_id
        debug @conf

        get_dirtree

        # dir
        #uri = URI('https://gitlab-test/api/v3/projects/2/repository/tree?path=lib')
        # subdir
        #uri = URI('https://gitlab-test/api/v3/projects/2/repository/tree?path=lib')
        # file
        #uri = URI('https://gitlab-test/api/v3/projects/2/repository/blobs/master?filepath=lib/library1.lib')
    end

    private

    def get_dirtree
        debug "enter get_dirtree"
        
        # TODO
        # add logic to decide here to create a top dir or not

        get_subdir @conf[:path]
    end

    # TODO
    # implement the create option, if create is false, no directory should be 
    def get_subdir(dir=nil,create=true)
        debug "enter get_subdir"

        # check for options
        args=[]
        args<<%(path=#{dir}) unless dir.nil?
        args<<%(ref_name=#{@conf[:branch]}) unless @conf[:branch].nil?
        
        # define path
        path="/api/v3/projects/#{@conf[:project_id]}/repository/tree"
        
        # add options to path unless args is empty
        path+="?"+args.join("&") unless args.empty?

        result=get path
        debug "result tree",result
        
        result.each do |entry|
            # print tree unless @conf[:verbose] is nil
            unless @conf[:verbose].nil?
                unless dir.nil?
                    puts %(#{dir}/#{entry['name']} [#{entry['type']}])
                else
                    puts %(#{entry['name']} [#{entry['type']}])
                end
            end
            
            # TODO erzeugen des unterverzeichnisses (mkdir)

            # TODO chdir in das unterverzeichnis

            # TODO ziehen aller files
            # check here the path: if it specify a file/blob we could pull the data and
            # print directly to stdout, if the regarding option is set


            # fuer jedes unterverzeichnis get_subdir aufrufen
            if entry['type']=='tree'
                if dir.nil?
                    get_subdir entry['name']
                else
                    get_subdir dir+"/"+entry['name']
                end
            end
        end
    end

    def update_project_id
        path="/api/v3/projects"
        debug "get path"
        r=get path
        debug "collect data"
        r.each{|project|
            if (
                (project['http_url_to_repo'] == @conf[:uri]) or
                (project['web_url'] == @conf[:uri])
            )
                @conf[:project_id]=project['id']
            end
        }
    end

    def update_private_token
        path="/api/v3/session"
        pass=ENV[@conf[:passvarname]]
        postdata=URI.encode("login=#{@conf[:username]}&password=#{pass}")
        r=post path,postdata
        debug "user id",r
        @conf[:privat_token]=r['private_token']
    end

    def get(path)
        debug "GET",path
        http=connection
        data=""
        resp = http.get(
            path,
            'PRIVATE-TOKEN' => @conf[:privat_token]
        ){|l|
            data+=l
        }
        if(resp.content_type=="application/json")
            return JSON.parse(data)
        else
            return data
        end
    end

    def post(path,postdata)
        #path="/api/v3/session"
        data=''
        pass=ENV[@conf[:passvarname]]
        postdata=URI.encode("login=#{@conf[:username]}&password=#{pass}")
        http=connection
        resp = http.post(path,postdata){|l|data+=l}
        if(resp.content_type=="application/json")
            return JSON.parse(data)
        else
            return data
        end
    end

    # generate a new http/https connection object
    def connection
        debug "create connection",@conf[:uri]
        uri=URI(@conf[:uri])
        debug "Net::HTTP.new", uri.host, uri.port
        http = Net::HTTP.new(uri.host, uri.port)

        # TODO
        # check URI for http/https
        http.use_ssl = true

        # TODO
        # make it configureable over dcommand line flags
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        
        return http
    end

    def option_parser
        option_parser = OptionParser.new do |opts|
            #opts.banner = "Usage: example.rb [options]"
            opts.on( "-d", "--debug", "enable debug mode") do
                @conf[:debug] = true
            end
            opts.on( "-v", "--verbose", "enable verbose printing") do
                @conf[:verbose] = true
            end
            opts.on( "-m", "--mode (gitlab|git)", "set mode, default is 'gitlab'") do |option|
                @conf[:mode]=option
            end
            opts.on( "-u", "--username USERNAME", "set username") do |option|
                @conf[:username]=option
            end
            opts.on( "-p", "--passvarname NAME",
                "set set the name with the environment variable",
                "default is GITPASS",
                "Example:",
                "  PASS=123 #{File.basename $0} -p PASS"
            ) do |option|
                @conf[:passvarname]=option
            end
            opts.on( "-r", "--repository URI", "set repository URL",
                "Example: #{File.basename $0}"
            ) do |option|
                @conf[:uri]=option
            end
            opts.on( "-a", "--path PATH", "fetch all files from PATH",
                "Example: #{File.basename $0}"
            ) do |option|
                @conf[:path]=option
            end
        end
        option_parser.parse!
    end

    def debug *a
        if @conf[:debug]==true
            pp a
        end
    end
    
end

# don't run this part neither load from another script nor irb
if $0 == __FILE__
    @fgs = FetchGitSubdir.new
    @fgs.run
end
